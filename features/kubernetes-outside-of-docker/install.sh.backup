#!/bin/bash

# kubernetes-outside-of-docker feature installer
# Configures kubectl to access host Kubernetes cluster from dev container with runtime initialization

set -e

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [[ -f "${SCRIPT_DIR}/utils.sh" ]]; then
    source "${SCRIPT_DIR}/utils.sh"
elif [[ -f "${SCRIPT_DIR}/../../common/utils.sh" ]]; then
    source "${SCRIPT_DIR}/../../common/utils.sh"
else
    echo "Error: Could not find utils.sh"
    exit 1
fi

log_info "ğŸ”§ Setting up Kubernetes access from dev container..."

# Simple user detection
if [ "$(id -u)" = "0" ]; then
    CONTAINER_USER="root"
    USER_HOME="/root"
else
    CONTAINER_USER="${USER:-vscode}"
    USER_HOME="${HOME:-/home/$CONTAINER_USER}"
fi

log_info "ğŸ“‹ Container user: $CONTAINER_USER"
log_info "ğŸ“ User home: $USER_HOME"

KUBE_DIR="$USER_HOME/.kube"
HOST_KUBE_MOUNT="/tmp/host-kube"
INIT_SCRIPT="/usr/local/share/kubernetes-init.sh"

# Ensure .kube directory exists
mkdir -p "$KUBE_DIR"
if [ "$CONTAINER_USER" != "root" ]; then
    chown -R "$CONTAINER_USER:$CONTAINER_USER" "$KUBE_DIR" 2>/dev/null || true
fi

# Create runtime initialization script for dynamic configuration
log_info "ğŸ“ Creating runtime initialization script"
cat > "$INIT_SCRIPT" << 'INIT_SCRIPT_EOF'
#!/bin/bash

# Kubernetes runtime initialization script
# This script configures kubectl access when the container starts or when kubectl is run

set -e

# Detect the container user
if [ "$(id -u)" = "0" ]; then
    CONTAINER_USER="root"
    USER_HOME="/root"
elif [ -n "$_REMOTE_USER" ]; then
    CONTAINER_USER="$_REMOTE_USER"
    USER_HOME="/home/$_REMOTE_USER"
elif [ -n "$USER" ]; then
    CONTAINER_USER="$USER"
    USER_HOME="${HOME:-/home/$USER}"
else
    CONTAINER_USER="vscode"
    USER_HOME="/home/vscode"
fi

KUBE_DIR="$USER_HOME/.kube"
HOST_KUBE_MOUNT="/tmp/host-kube"

# Ensure .kube directory exists
mkdir -p "$KUBE_DIR"
if [ "$CONTAINER_USER" != "root" ] && command -v chown >/dev/null 2>&1; then
    chown -R "$CONTAINER_USER:$CONTAINER_USER" "$KUBE_DIR" 2>/dev/null || true
fi

# Check if host mount directory exists
if [ ! -d "$HOST_KUBE_MOUNT" ]; then
    echo "âš ï¸  Host .kube directory not mounted at $HOST_KUBE_MOUNT"
    echo "   Add this mount to your devcontainer.json:"
    echo '   {
     "source": "${localEnv:HOME}/.kube",
     "target": "/tmp/host-kube",
     "type": "bind"
   }'
    echo "   For Windows, use \${localEnv:USERPROFILE} instead of \${localEnv:HOME}"
    return 0 2>/dev/null || exit 0
fi

# Copy and fix host kubeconfig if available
if [ -f "$HOST_KUBE_MOUNT/config" ]; then
    echo "ğŸ“‹ Configuring kubectl for container access..."
    
    # Get gateway IP for host connectivity
    GATEWAY_IP=$(ip route show default 2>/dev/null | awk '/default/ {print $3}' | head -n1)
    if [ -z "$GATEWAY_IP" ]; then
        GATEWAY_IP="172.17.0.1"
    fi
    
    # For Docker Desktop, try the known working IP that matches certificates
    DOCKER_DESKTOP_IP="192.168.65.3"
    if ping -c 1 -W 1 "$DOCKER_DESKTOP_IP" >/dev/null 2>&1; then
        GATEWAY_IP="$DOCKER_DESKTOP_IP"
        echo "ğŸ³ Using Docker Desktop IP: $GATEWAY_IP"
    else
        echo "ğŸŒ Using gateway IP: $GATEWAY_IP"
    fi
    
    # Copy and fix the kubeconfig
    cp "$HOST_KUBE_MOUNT/config" "$KUBE_DIR/config"
    
    # Replace localhost, 127.0.0.1, and kubernetes.docker.internal with gateway IP
    sed -i "s|server: https://127\.0\.0\.1[:/]|server: https://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: https://localhost[:/]|server: https://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: http://127\.0\.0\.1[:/]|server: http://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: http://localhost[:/]|server: http://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: https://127\.0\.0\.1$|server: https://$GATEWAY_IP:6443|g" "$KUBE_DIR/config"
    sed -i "s|server: https://localhost$|server: https://$GATEWAY_IP:6443|g" "$KUBE_DIR/config"
    sed -i "s|server: http://127\.0\.0\.1$|server: http://$GATEWAY_IP:8080|g" "$KUBE_DIR/config"
    sed -i "s|server: http://localhost$|server: http://$GATEWAY_IP:8080|g" "$KUBE_DIR/config"
    sed -i "s|server: https://kubernetes\.docker\.internal[:/]|server: https://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: http://kubernetes\.docker\.internal[:/]|server: http://$GATEWAY_IP:|g" "$KUBE_DIR/config"
    sed -i "s|server: https://kubernetes\.docker\.internal$|server: https://$GATEWAY_IP:6443|g" "$KUBE_DIR/config"
    sed -i "s|server: http://kubernetes\.docker\.internal$|server: http://$GATEWAY_IP:8080|g" "$KUBE_DIR/config"
    
    # Set ownership
    if [ "$CONTAINER_USER" != "root" ] && command -v chown >/dev/null 2>&1; then
        chown "$CONTAINER_USER:$CONTAINER_USER" "$KUBE_DIR/config" 2>/dev/null || true
    fi
    
    echo "âœ… Kubernetes configuration updated for container access"
else
    echo "â„¹ï¸  No kubeconfig found at $HOST_KUBE_MOUNT/config"
fi

# Set KUBECONFIG environment variable
export KUBECONFIG="$KUBE_DIR/config"
INIT_SCRIPT_EOF

chmod +x "$INIT_SCRIPT"

# Create symlink for compatibility with existing documentation
ln -sf "$INIT_SCRIPT" "/usr/local/share/docker-init.sh"

# Check if host mount exists for initial setup
if [ ! -d "$HOST_KUBE_MOUNT" ]; then
    log_warning "âš ï¸  Host .kube directory not mounted at $HOST_KUBE_MOUNT"
    log_info "Add this mount to your devcontainer.json:"
    echo '{
  "mounts": [
    {
      "source": "${localEnv:HOME}/.kube",
      "target": "/tmp/host-kube",
      "type": "bind"
    }
  ]
}'
    # Don't exit - still create the initialization script
fi

# Run initial configuration if host mount is available
if [ -d "$HOST_KUBE_MOUNT" ]; then
    log_info "ï¿½ Running initial configuration..."
    bash "$INIT_SCRIPT"
fi

# Set up environment variables for shell sessions
log_info "ï¿½ Setting up environment variables..."
cat > /etc/profile.d/kubernetes-outside-docker.sh << 'PROFILE_EOF'
#!/bin/bash
# Kubernetes outside-of-docker environment setup

# Set KUBECONFIG based on user
if [ "$(id -u)" = "0" ]; then
    export KUBECONFIG="/root/.kube/config"
else
    export KUBECONFIG="$HOME/.kube/config"
fi

# Function to run kubernetes initialization if needed
ensure_kubectl_config() {
    if [ ! -f "$KUBECONFIG" ] && [ -f "/usr/local/share/kubernetes-init.sh" ]; then
        echo "ğŸ”§ Initializing Kubernetes configuration..."
        bash /usr/local/share/kubernetes-init.sh
    fi
}

# Run initialization automatically when profile loads
ensure_kubectl_config 2>/dev/null || true
PROFILE_EOF

chmod +x /etc/profile.d/kubernetes-outside-docker.sh

# Set KUBECONFIG for current session
export KUBECONFIG="$KUBE_DIR/config"
log_success "âœ… KUBECONFIG set to: $KUBECONFIG"

# Test kubectl if available and configuration exists
if command -v kubectl >/dev/null 2>&1; then
    log_info "ğŸ§ª Testing kubectl configuration..."
    
    # Verify KUBECONFIG file exists
    if [ -f "$KUBECONFIG" ]; then
        log_info "âœ… KUBECONFIG file exists: $KUBECONFIG"
        
        # Show current context info
        if kubectl config current-context --request-timeout=2s >/dev/null 2>&1; then
            CURRENT_CONTEXT=$(kubectl config current-context)
            log_info "ğŸ“‹ Current context: $CURRENT_CONTEXT"
        else
            log_warning "âš ï¸  No current context set or invalid configuration"
        fi
        
        # Test actual connection with short timeout
        if kubectl cluster-info --request-timeout=3s >/dev/null 2>&1; then
            log_success "âœ… kubectl connection successful!"
            kubectl get nodes --request-timeout=3s 2>/dev/null | head -n 3 || true
        else
            log_warning "âš ï¸  kubectl connection test failed"
            log_info "ğŸ’¡ This may be normal if the cluster requires authentication or is not accessible"
            log_info "ğŸ’¡ Try running 'kubectl get nodes' manually to test connectivity"
        fi
    else
        log_warning "âš ï¸  KUBECONFIG file not found: $KUBECONFIG"
        log_info "ğŸ’¡ Configuration will be created when container starts with proper mount"
    fi
else
    log_info "â„¹ï¸  kubectl not found - install kubectl feature first"
fi

log_success "ğŸ‰ Kubernetes outside-of-docker setup complete!"
log_info ""
log_info "ï¿½ Setup summary:"
log_info "  â€¢ Runtime initialization script: $INIT_SCRIPT"
log_info "  â€¢ Mount host .kube directory to: $HOST_KUBE_MOUNT"
log_info "  â€¢ Configuration will be automatically updated on container start"
log_info "  â€¢ KUBECONFIG will be set to use container-accessible IPs"
log_info ""
log_info "ğŸ’¡ Next steps:"
log_info "  1. Ensure your devcontainer.json mounts the host .kube directory"
log_info "  2. Start your devcontainer"
log_info "  3. Run 'kubectl get nodes' to test connectivity"
